[CmdletBinding()]
Param
(
    [Parameter()]
    [ValidateNotNull()]
    [Hashtable] $Parameters = @{}
)

$CipherDll = Join-Path $PSScriptRoot "bin\Cipher.dll"

If (-not (Test-Path -PathType Leaf $CipherDll))
{
    Throw "FATAL: Unable to find the Cipher.dll. Make sure the library is compiled and placed at $CipherDll"
}

$AssemblyLoaded = $False

Function Invoke-Collection
{
<#
    .SYNOPSIS
        Generates a sequence of symmetric encryption transformations.
    .DESCRIPTION
        Runs a specified encruption algorithm against the plaintext. Produces
        binary files in the specified directory. Each file contains corresponding
        intermediate ciphertext. The first file contains the plaintext. The last one
        contains the final ciphertext. The key and the initialization vector are also
        saved in the folder.
    .PARAMETER Algorithm
        An encryption algorithm to use. Only AES is currently supported.
    .PARAMETER PlainText
        A plain text to feed the algorithm. A plaintext could be specified in one of the
        following forms:
          - A byte array (instance of [System.Byte[]]). It is passed into the algorithm as is.
          - A unicode string (instance of [System.String]). The string is serialized into a byte
            array using UTF8 encoding.
          - A path to a file or an instance of [System.IO.FileInfo]. The byte array is read from
            the file.
    .PARAMETER KeySize
        A size of the key in bytes. The parameter is used only if a key is generated by the
        algorithm. It is ignored if the Key parameter is specified.
    .PARAMETER Key
        A key of the cipher. If the parameter is not specified the key is randomly generated.
    .PARAMETER InitializationVector
        An initialization vector of the cipher. If the parameter is not specified the vector is
        randomly generated.
    .PARAMETER OutputFolder
        A path to a directory to hold the encryption sequence files. If the directory does not exists
        it is created.
    .PARAMETER OutputFormat
        Specifies a file naming scheme. A format string may contain the following tokens:
          - {algorithm} - is replaced with an algorithm name
          - {iteration} - is replaced with an index of transformation. The index "0" corresponds
            to the plaintext. The indices "key" and "iv" correspond to the key and initialization
            vector.
        Default format is "{algorithm}-{iteration}.bin" so files "aes-key.bin", "aes-iv.bin", "aes-0.bin",
        "aes-1.bin" etc. are created in the folder.
    .PARAMETER Mode
        A mode of the AES algorithm. Only ECB (electronic codebook) and CBC (cipher block chaining)
         are supported.
    .EXAMPLE
        PS C:\> Invoke-CipherCollection -Algorithm AES -PlainText "inputs\input-1.bin" -OutputFolder "output\aes-256-cbc"
        Reads plaintext from the file "inputs\input-1.bin" and runs an AES encryption in CBC mode with
        self-generated 256-bit key and initialization vector. Places the key, IV, plaintext, ciphertext as well
        as 16 intermediate results in the folder "output".
    .EXAMPLE
        PS C:\> $KeyPath = (Resolve-Path "output\aes-256-cbc\aes-key.bin").Path
        PS C:\> $IVPath = (Resolve-Path "output\aes-256-cbc\aes-iv.bin").Path
        PS C:\> $Key = [System.IO.File]::ReadAllBytes($KeyPath)
        PS C:\> $IV = [System.IO.File]::ReadAllBytes($IVPath)
        PS C:\> Invoke-CipherCollection -Algorithm AES -PlainText "inputs\input-1.bin" -OutputFolder "output\aes-256-ecb" -Mode ECB
        Reads plaintext from the file "inputs\input-1.bin" and runs an AES encryption in ECB mode with
        the specified key and initialization vector. This can be used to analyze how CBC disabling affects
        encryption with the same key.
    .OUTPUTS
        [System.IO.FileInfo] for each created file in an output directory.
    #>
    [CmdletBinding()]
    Param
    (
        [Parameter(Mandatory = $True)]
        [ValidateSet("AES")]
        [System.String] $Algorithm,

        [Parameter(Mandatory = $True)]
        [System.Object] $PlainText,

        [Parameter()]
        [System.Int32] $KeySize,

        [Parameter()]
        [System.Byte[]] $Key = $Null,

        [Parameter()]
        [System.Byte[]] $InitializationVector = $Null,

        [Parameter(Mandatory = $True)]
        [System.String] $OutputFolder,

        [Parameter()]
        [System.String] $OutputFormat = "{algorithm}-{iteration}.bin",

        [Parameter(ParameterSetName = "AES")]
        [ValidateSet("ECB", "CBC")]
        [System.String] $Mode = $Null
    )

    $OriginalErrorPreference = $ErrorPreference
    $ErrorPreference = "Stop"

    Try
    {
        If ($PlainText -isnot [System.Byte[]])
        {
            If ($PlainText -is [System.IO.FileInfo])
            {
                Write-Verbose "Read plain text from the file $($PlainText.FullName)"
                $PlainText = [System.IO.File]::ReadAllBytes($PlainText.FullName)
            }
            ElseIf ($PlainText -isnot [System.String])
            {
                Throw "Plain text must be a byte array, a string or a path to a file"
            }
            ElseIf (Test-Path -PathType Leaf $PlainText)
            {
                Write-Verbose "Read plain text from the file $PlainText"
                $PlainText = (Resolve-Path $PlainText).Path
                $PlainText = [System.IO.File]::ReadAllBytes($PlainText)
            }
            Else
            {
                Write-Verbose "Convert plain text string $PlainText into byte array"
                $PlainText = [System.Text.Encoding]::UTF8.GetBytes($PlainText)
            }
        }

        Write-Verbose "Plain text size: $($PlainText.Length) bytes"

        If (-not (Test-Path -PathType Container $OutputFolder))
        {
            New-Item $OutputFolder -ItemType Directory | Out-Null
            Write-Verbose "Output directory $OutputFolder created"
        }

        $OutputFolder = (Resolve-Path $OutputFolder).Path

        Function Write-CipherOutput
        {
            Param($Content, $Folder, $Format, $Arguments)

            $FileName = $Format
            $Arguments.Keys | ForEach-Object {
                $FileName = $FileName -replace "{${_}}", $Arguments[$_]
            }

            $FilePath = Join-Path $Folder $FileName

            [System.IO.File]::WriteAllBytes($FilePath, $Content)

            Get-Item $FilePath
        }

        $OutputFileArgs = @{
            "algorithm" = "aes"
            "iteration" = "0"
        }

        Write-CipherOutput $PlainText $OutputFolder $OutputFormat $OutputFileArgs

        If (-not $global:AssemblyLoaded)
        {
            [System.Reflection.Assembly]::LoadFile($CipherDll) | ForEach-Object {
                Write-Verbose "The assembly $($_.FullName) has been loaded"
            }
            $global:AssemblyLoaded = $True
        }

        $Target = [Cipher.Algorithms.AES.AES]::new()

        If ($Key)
        {
            $Target.Key = $Key
            Write-Verbose "Use the specified key of the size $($Key.Length * 8)"
        }
        Else
        {
            If ($KeySize)
            {
                $Target.KeySize = $KeySize
            }
            Write-Verbose "Use the $($Target.Key.Length * 8)-bit self-generated key"
        }

        If ($InitializationVector)
        {
            $Target.IV = $InitializationVector
            Write-Verbose "Use the specified IV of the size $($Target.IV.Length * 8)"
        }
        Else
        {
            Write-Verbose "Use the $($Target.IV.Length * 8)-bit self-generated IV"
        }

        $OutputFileArgs["iteration"] = "key"
        Write-CipherOutput $Target.Key $OutputFolder $OutputFormat $OutputFileArgs

        $OutputFileArgs["iteration"] = "iv"
        Write-CipherOutput $Target.IV $OutputFolder $OutputFormat $OutputFileArgs

        If ($Mode)
        {
            $Target.Mode = $Mode
        }

        Write-Verbose "Use the $($Target.Mode) operation mode"

        [Cipher.Collector]::Encrypt($Target, $PlainText) | ForEach-Object -Begin {
            $i = 1
            Write-Verbose "Encryption completed"
        } -Process {
            $OutputFileArgs["iteration"] = $i
            $i++
            Write-CipherOutput $_ $OutputFolder $OutputFormat $OutputFileArgs
        }
    }
    Finally
    {
        $ErrorPreference = $OriginalErrorPreference
    }
}

New-Alias -Name ".Collect" -Value "Invoke-Collection" -Description (
    "Generate encryption sequence"
)

Export-ModuleMember -Function @(
    "Invoke-Collection"
) -Alias @(
    ".Collect"
)